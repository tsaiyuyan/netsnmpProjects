/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <time.h>
#define DISABLE_MIB_LOADING
extern int netsnmp_running;

//const char *our_master_agent_ip = "tcp:172.16.28.118:1610";
const char *our_master_agent_ip = "tcp:localhost:1610";
/* function declarations */
void init_Test(void);
Netsnmp_Node_Handler handle_GetTime;
Netsnmp_Node_Handler handle_yuyan_func;

/** Initializes the Test module */
void init_Test(void)
{
    const oid GetTime_oid[] = {1, 3, 6, 1, 4, 1, 16535, 1, 1};

    DEBUGMSGTL(("Test", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("GetTime", handle_GetTime,
                                            GetTime_oid, OID_LENGTH(GetTime_oid),
                                            HANDLER_CAN_RONLY));

    const oid yuyan_func_oid[] = {1, 3, 6, 1, 4, 1, 16536, 1, 1};

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("yuyan", handle_yuyan_func,
                                            yuyan_func_oid, OID_LENGTH(yuyan_func_oid),
                                            /*HANDLER_CAN_RONLY*/ HANDLER_CAN_RWRITE));
}

int handle_GetTime(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    time_t t;
    printf("handle_GetTime\n");
    switch (reqinfo->mode)
    {

    case MODE_GET:
        time(&t);
        char szTime[100];
        snprintf(szTime, 100, "%s", ctime(&t));
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 /* XXX: a pointer to the scalar's data */ szTime,
                                 /* XXX: the length of the data in bytes */ strlen(szTime));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_GetTime\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

static int g_yuyan_value = 0;

int handle_yuyan_func(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int rc;

    printf("yuyan_funci %d\n", g_yuyan_value);
    switch (reqinfo->mode)
    {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /* XXX: a pointer to the scalar's data */ &g_yuyan_value,
                                 /* XXX: the length of the data in bytes */ sizeof(g_yuyan_value));
        break;

#ifndef NETSNMP_NO_WRITE_SUPPORT
        /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
    case MODE_SET_RESERVE1:
        rc = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (rc != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, rc);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
             * store old info for undo later
             */
        if (0 /* XXX if malloc, or whatever, failed: */)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
        break;

    case MODE_SET_ACTION:
        /* XXX: perform the value change here */
        g_yuyan_value = *(requests->requestvb->val.integer);

        rc = 0;
        if (0 != rc)
        {
            netsnmp_set_request_error(reqinfo, requests, rc);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        g_yuyan_value = *((u_long *)netsnmp_request_get_list_data(requests, "yuyan_value"));
        rc = 0;
        if (0 != rc)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        }
        break;
#endif /* !NETSNMP_NO_WRITE_SUPPORT */

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_GetTime\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

RETSIGTYPE
stop_server(int a)
{
    netsnmp_running = 0;
}

int main(int argc, char *argv[])
{
    fprintf(stderr, "NET-SNMP version: %s\n", netsnmp_get_version());
    
    //netsnmp_init_mib();
    netsnmp_set_mib_directory("/usr/local/net-snmp/share/snmp/mibs");
    //add_mibdir("/usr/local/net-snmp/share/snmp/mibs");

    const char *app_name = "Test";
    int dont_fork = 1;
    if(argc == 1)
    {
        printf("our_master_agent_ip: %s\n", our_master_agent_ip);
        netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_X_SOCKET, our_master_agent_ip);
    }else
    {
        printf("target_master_agent_ip: %s\n", argv[1]);
        netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_X_SOCKET, argv[1]);
    }

    /* we are a subagent */
    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 1);

    if (!dont_fork)
    {
        if (netsnmp_daemonize(1, snmp_stderrlog_status()) != 0)
            exit(1);
    }

    /* initialize the agent library */
    init_agent(app_name);

    /* initialize your mib code here */
    init_Test();

    /* Test will be used to read Test.conf files. */
    init_snmp("Test");

    /* In case we received a request to stop (kill -TERM or kill -INT) */
    netsnmp_running = 1;
#ifdef SIGTERM
    signal(SIGTERM, stop_server);
#endif
#ifdef SIGINT
    signal(SIGINT, stop_server);
#endif

    /* main loop here... */
    while (netsnmp_running)
    {
        agent_check_and_process(1);
    }

    /* at shutdown time */
    snmp_shutdown(app_name);

    /* deinitialize your mib code here */
    /* shutdown the agent library */
    shutdown_agent();
    exit(0);
}